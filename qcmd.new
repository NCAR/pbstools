#!/bin/bash

handle_logs () {
    rm -f $CMDSCRIPT

    # Get exit status from script
    if [[ -f $QCMD_LOG ]]; then
        RETCODE=$(grep -m1 "^%qcmddone%" $QCMD_LOG | cut -d' ' -f2)

        if [[ $RETCODE -eq 0 ]]; then
            QCMD_MSG="Job exited normally"
        else
            QCMD_MSG="Job exited with non-zero status"
        fi
        
        if [[ ! -z $LOGPATH ]]; then
            echo -e "\n\nWriting output to specified log file at:"
            echo "    $LOGPATH"
            sed -i '/^%qcmddone%/d' $QCMD_LOG
            echo -e "\nQCMD: $QCMD_MSG" >> $QCMD_LOG
            mv $QCMD_LOG $LOGPATH
        else
            rm -f $QCMD_LOG
        fi

        exit $RETCODE
    fi
}

clean_up () {
    if /glade/u/apps/ch/opt/usr/bin/qstat ${QCMD_JOB%%.*} &> /dev/null; then
        qdel $QCMD_JOB 2> /dev/null
    fi
    
    if [[ ! -z $QCMD_JOB ]]; then
        echo -e "\nqcmd job $QCMD_JOB terminated"
        sleep 5
        handle_logs
    fi

    exit 1
}

trap clean_up SIGHUP SIGINT SIGQUIT SIGTERM

# Here are the default settings at the moment
NODES=1
CPUS=36
MPIPROCS=36
QUEUE=regular
WALLTIME=3600
JOB_ACCOUNT=

usage () {
cat << EOF
Usage: qcmd [PBS options] -- executable [arguments]

This script will run a command/executable on the regular queue using one node
by default. Any arguments submitted to the script will be forwarded to the qsub
command, enabling you to override script defaults (e.g., walltime). Note that
commands run using qcmd will *not* have interactive terminal support. Please
use qinteractive or qsub -I for interactive jobs. Jobs created by qcmd will be
provided with a login node environment, enabling activities like compilation.

You have three ways of selecting an account to use for the submission:

1. Use the PBS -A [account] command line argument
2. Set the PBS_ACCOUNT environment variable
3. Let qcmd randomly select from your active project list

Current PBS_ACCOUNT value = $PBS_ACCOUNT
EOF
exit $1
}

# Parse command line arguments
ARGV="$@"
PBSOPT="${ARGV%%-- *}"
EXECMD="${ARGV##*-- }"

for n in $PBSOPT; do
    case $n in
        --help)
            usage 0
            ;;
        -A*)
            if [[ $n == -A ]]; then
                READVAL=account
            else
                JOB_ACCOUNT=${n/-A/}
            fi
            ;;
        -o*)
            if [[ $n == -o ]]; then
                READVAL=logpath
            else
                LOGPATH=${n/-o/}
            fi
            ;;
        -e*)
            echo "Note: separate output and error log files are not supported by qcmd"
            ;;
        *)
            case $READVAL in
                account)
                    JOB_ACCOUNT=$n
                ;;
                logpath)
                    LOGPATH=$n
                ;;
            esac
            READVAL=
            ;;
    esac
done

if [[ $ARGV != *"-- "* ]]; then
    echo "Error: no command specified!"
    usage 1
fi

# If JOB_ACCOUNT is still not set, then use defaults
if [[ -z $JOB_ACCOUNT ]]; then
    if [[ -z $PBS_ACCOUNT ]]; then
        JOB_ACCOUNT=$(/ncar/opt/sam/sam_validate.py $USER | grep -m1 True | cut -d ',' -f 1)
    else
        JOB_ACCOUNT=$PBS_ACCOUNT
    fi

    PBSARGS="-A $JOB_ACCOUNT"
fi

# Create default list of arguments
PBSARGS="-l select=${NODES}:ncpus=${CPUS}:mpiprocs=${MPIPROCS}      \
            -l walltime=${WALLTIME} -q ${QUEUE} -l inception=login  \
            ${PBSARGS}"

echo "Submitting command to PBS using account ${JOB_ACCOUNT}:"
echo -e "    $EXECMD\n"

# Put any user requests second to override defaults
if [[ ! -z $PBSOPT ]]; then
    echo -e "Requested custom PBS options:\n    $PBSOPT\n"

    PBSARGS="$PBSARGS $PBSOPT"
fi

# If running in a PBS job, use original shell
if [[ ! -z $PBS_O_SHELL ]]; then
    JOBSHELL=$PBS_O_SHELL
else
    JOBSHELL=$SHELL
fi

# Submit job request using temp script and write output to home directory
mkdir -p ~/.qcmd
CMDSCRIPT=~/.qcmd/script.$$

cat > $CMDSCRIPT << EOF
#!/bin/bash

function badexit {
    echo "%qcmddone% 1"
}

trap badexit SIGTERM

$JOBSHELL -c "$EXECMD"
CMDSTAT=\$?
echo "%qcmddone% \$CMDSTAT"
exit \$CMDSTAT
EOF

# Submit job and get job ID
SECONDS=0
QCMD_LOG=$HOME/.qcmd/out.$$
QCMD_JOB=$(qsub $PBSARGS -j oe -k oed -o $QCMD_LOG -N qcmd $CMDSCRIPT 2>&1)
QSUB_RET=$?

# Check that job ID was produced
if [[ $QSUB_RET != 0 ]]; then
    echo $QCMD_JOB
    echo "Error: error in qsub submission. Exiting ..."
    exit $QSUB_RET
fi

echo -e "Waiting for job $QCMD_JOB to start ... \n\n"

while [[ ! -f $QCMD_LOG ]]; do
    if [[ $SECONDS -gt 30 ]] && ! /glade/u/apps/ch/opt/usr/bin/qstat ${QCMD_JOB%%.*} &> /dev/null; then
        echo "Error: PBS could not successfully start job. Exiting..."
        exit 1
    fi

    sleep 1
done

# Follow job output
tail -n +1 -f $QCMD_LOG | while read LOGLINE; do
    if [[ $LOGLINE == %qcmddone%* ]]; then
        pkill -P $$ tail
    else
        echo $LOGLINE
    fi
done

# Get exit code and clean up
handle_logs
