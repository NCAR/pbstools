#!/bin/bash

handle_logs () {
    if [[ ! -z $QCMD_TPID ]]; then
        kill $QCMD_TPID
    fi

    if [[ -f $QCMD_LOG ]]; then
        if [[ ! -z $LOGPATH ]]; then
            echo -e "\n\nWriting output to specified log file at:"
            echo "    $LOGPATH"
            echo -e "\nQCMD: $1" >> $QCMD_LOG
            mv $QCMD_LOG $LOGPATH
        else
            rm -f $QCMD_LOG
        fi
    fi
    
    rm -f $CMDSCRIPT $JOBIDFILE
}

check_job () {
    if ! kill -0 $QCMD_SPID >& /dev/null; then
        echo "Error: PBS could not successfully start job. Exiting..."
        exit 1
    fi

    sleep 1
}

clean_up () {
    sleep 5
    if [[ ! -z $QCMD_JOB ]]; then
        echo -e "\nqcmd job $QCMD_JOB terminated"
        handle_logs "Job terminated before completion"
    fi
    exit 2
}

trap clean_up SIGHUP SIGINT SIGQUIT SIGTERM

# Here are the default settings at the moment
NODES=1
CPUS=36
MPIPROCS=36
QUEUE=regular
WALLTIME=3600
JOB_ACCOUNT=

usage () {
cat << EOF
Usage: qcmd [PBS options] -- executable [arguments]

This script will run a command/executable on the regular queue using one node
by default. Any arguments submitted to the script will be forwarded to the qsub
command, enabling you to override script defaults (e.g., walltime). Note that
commands run using qcmd will *not* have interactive terminal support. Please
use qinteractive or qsub -I for interactive jobs. Jobs created by qcmd will be
provided with a login node environment, enabling activities like compilation.

You have three ways of selecting an account to use for the submission:

1. Use the PBS -A [account] command line argument
2. Set the PBS_ACCOUNT environment variable
3. Let qcmd randomly select from your active project list

Current PBS_ACCOUNT value = $PBS_ACCOUNT
EOF
exit $1
}

# Parse command line arguments
ARGV="$@"
PBSOPT="${ARGV%%-- *}"
EXECMD="${ARGV##*-- }"

for n in $PBSOPT; do
    case $n in
        --help)
            usage 0
            ;;
        -A*)
            if [[ $n == -A ]]; then
                READVAL=account
            else
                JOB_ACCOUNT=${n/-A/}
            fi
            ;;
        -o*)
            if [[ $n == -o ]]; then
                READVAL=logpath
            else
                LOGPATH=${n/-o/}
            fi
            ;;
        -e*)
            echo "Note: separate output and error log files are not supported by qcmd"
            ;;
        *)
            case $READVAL in
                account)
                    JOB_ACCOUNT=$n
                ;;
                logpath)
                    LOGPATH=$n
                ;;
            esac
            READVAL=
            ;;
    esac
done

if [[ $ARGV != *"-- "* ]]; then
    echo "Error: no command specified!"
    usage 1
fi

# If JOB_ACCOUNT is still not set, then use defaults
if [[ -z $JOB_ACCOUNT ]]; then
    if [[ -z $PBS_ACCOUNT ]]; then
        JOB_ACCOUNT=$(/ncar/opt/sam/sam_validate.py $USER | grep -m1 True | cut -d ',' -f 1)
    else
        JOB_ACCOUNT=$PBS_ACCOUNT
    fi

    PBSARGS="-A $JOB_ACCOUNT"
fi

# Create default list of arguments
PBSARGS="-l select=${NODES}:ncpus=${CPUS}:mpiprocs=${MPIPROCS}      \
            -l walltime=${WALLTIME} -q ${QUEUE} -l inception=login  \
            ${PBSARGS}"

echo "Submitting command to PBS using account ${JOB_ACCOUNT}:"
echo -e "    $EXECMD\n"

# Put any user requests second to override defaults
if [[ ! -z $PBSOPT ]]; then
    echo -e "Requested custom PBS options:\n    $PBSOPT\n"

    PBSARGS="$PBSARGS $PBSOPT"
fi

# If running in a PBS job, use original shell
if [[ ! -z $PBS_O_SHELL ]]; then
    JOBSHELL=$PBS_O_SHELL
else
    JOBSHELL=$SHELL
fi

# Submit job request using temp script and write output to home directory
CMDSCRIPT=~/.qcmd.script.$$
JOBIDFILE=~/.qcmd.jobid.$$
cat > $CMDSCRIPT << EOF
#!$JOBSHELL
$EXECMD
EOF

# Submit job in background and then get job ID
qsub $PBSARGS -j oe -k oe -W block=true -N run/.qcmd $CMDSCRIPT > $JOBIDFILE &
QCMD_SPID=$!

while [[ ! -s $JOBIDFILE ]]; do
    check_job
done

QCMD_JOB=$(cat $JOBIDFILE)

# Check that job ID was produced
if [[ ! $QCMD_JOB =~ ^[0-9]+.* ]]; then
    echo $QCMD_JOB
    echo "Error: error in qsub submission. Exiting ..."
    exit 1
else
    QCMD_LOG=~/.qcmd.o${QCMD_JOB%%.*}
fi

echo -e "Waiting for job $QCMD_JOB to start ... \n\n"

while [[ ! -f $QCMD_LOG ]]; do
    check_job
done

# Follow job output
tail -n +1 -f $QCMD_LOG &
QCMD_TPID=$!

# Wait for the job to finish and give a little time to empty buffer
wait $QCMD_SPID
JOBCODE=$?
sleep 5

# Clean up
handle_logs "Job exited normally"
exit $JOBCODE
